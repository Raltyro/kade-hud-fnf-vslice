/**
 * Kade Engine HUD in FNF V-Slice Module By Raltyro
 * Trying my best to like document and explain whatever is going on in this module.
 * 
 * First made on 2 May 2024 Alongside with Nebula Zorua's COOLHUD V-Slice.
 * Final update at 7 June 2025 (hopefully).
 * FNF V-Slice (0.3.0, WeekEnd1 Update) was first publicly released on 1 May 2024,
 *  then it's source code released publicly at GitHub FunkinCrew, previously ninjamuffin99 Github's
 *  on May 6 2024.
 *  That time no documentation was available, only digging into Web HTML5 Build of the WeekEnd1 Update
 *  Funkin.js.
 *  Crowplexus & Nebula Zorua's was the first modders who figured out all of the polymod shit.
 * 
 * This was the only available documentation to FNF V-Slice Modding at 2 May 2024
 * https://github.com/crowplexus/Funkin-VSlice-Template/blob/master/Template_Module.hxc
 * 
 * Nowadays you can always check FunkinCrew/Funkin source code.
 * https://github.com/FunkinCrew/Funkin
 */

import funkin.graphics.FunkinSprite;
import funkin.modding.module.Module;
import funkin.play.scoring.Scoring;
import funkin.play.PlayState;
import funkin.ui.options.OptionsState;
import funkin.ui.options.OptionsMenu;
import funkin.ui.options.PreferencesMenu;
import funkin.util.Constants;
import funkin.Conductor;
import funkin.Highscore;
import funkin.Paths;
import funkin.Preferences;

import flixel.math.FlxMath;
import flixel.text.FlxTextBorderStyle;
import flixel.text.FlxText;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.ui.FlxBar;
import flixel.util.FlxSave;
import flixel.util.FlxSpriteUtil;
import flixel.util.FlxStringUtil;
import flixel.FlxBasic;
import flixel.FlxG;
import flixel.FlxState;
import flixel.FlxSprite;

// The main Module for this HUD Mod.
class KadeHUDModule extends Module {
	// Module & Saving Implementation in funkin.modding.IScriptedClass

	/**
	 * The module constructor is only (ModuleID, Priority)
	 * ModuleID has to be different with the other activated mods modules.
	 * Priority is the order runtime for this module. Higher being the first module to run.
	 */
	public function new() {
		super("KadeHUD", 1);
		initSave();
	}

	/**
	 * Haxeflixel can have 2 FlxSaves loaded at the same time.
	 * Though with being in the same application cache/saves in MacOS and non-desktop platforms supposedly.
	 * - Raltyro/kadehudvslice
	 * - FunkinCrew/Raltyro/kadehudvslice (?)
	 */
	var save:FlxSave;

	function initSave() {
		if (save != null) return;
		(save = new FlxSave()).bind("kadehudvslice", "Raltyro");

		// default
		if (save.data.enabled == null) save.data.enabled = true;
		if (save.data.accHoldToAcc == null) save.data.accHoldToAcc = true;
		if (save.data.simpleAcc == null) save.data.simpleAcc = false;
		if (save.data.showNPS == null) save.data.showNPS = false;
		if (save.data.showTapMisses == null) save.data.showTapMisses = true;
		if (save.data.showTimer == null) save.data.showTimer = true;
		if (save.data.showSongInfo == null) save.data.showSongInfo = true;
		if (save.data.showTiming == null) save.data.showTiming = false;
		if (save.data.centerStrums == null) save.data.centerStrums = true;
	}

	/**
	 * The destroy callback for modules.
	 * Though weird behavior of this being called in PlayState too instead of you know, being called
	 *  seperately like onPlayStateDestroy.
	 * 
	 * This is fucked.
	 */
	override function onDestroy(e:ScriptEvent) {
		cleanup();

		if (save != null) {
			save.close();
			save.destroy();
			save = null;
		}
	}

	/**
	 * Build a this HUD Mod Preferences Menu for OptionsState.
	 * You cannot extend PreferencesMenu, so we have to make it then modify it after.
	 */
	function buildModPreferencesMenu():PreferencesMenu {
		var menu:PreferencesMenu = new PreferencesMenu();

		// Destroy a pre-built Preferences Menu then make our own.
		for (item in menu.items) item.destroy();
		for (item in menu.preferenceItems) item.destroy();
		menu.items.clear();
		menu.preferenceItems.clear();
		menu.preferenceDesc = [];

		menu.onExit.add(() -> save.flush());

		menu.createPrefItemCheckbox("Enable Kade HUD", "Enables this Kade Engine HUD Mod.",
			(value) -> save.data.enabled = value, save.data.enabled);

		menu.createPrefItemCheckbox("Simple Accuracy", "Changes how the accuracy will display depending on how simple it is on this setting.",
			(value) -> save.data.simpleAcc = value, save.data.simpleAcc);

		menu.createPrefItemCheckbox("Account Hold to Acc", "If enabled, any hold will be accounted to accuracy in the score label.",
			(value) -> save.data.accHoldToAcc = value, save.data.accHoldToAcc);

		menu.createPrefItemCheckbox("Diff Timing Text", "If enabled, a text will popup on note indicating a timing differences.",
			(value) -> save.data.showTiming = value, save.data.showTiming);

		menu.createPrefItemCheckbox("Notes per Second", "If enabled, this'll shows text indicating NPS in the score label.",
			(value) -> save.data.showNPS = value, save.data.showNPS);

		menu.createPrefItemCheckbox("Tap Misses", "If enabled, this'll show text indicating How much tap misses in the score label.",
			(value) -> save.data.showTapMisses = value, save.data.showTapMisses);

		menu.createPrefItemCheckbox("Timer Bar", "If enabled, this'll show a timer bar on top of the screen.",
			(value) -> save.data.showTimer = value, save.data.showTimer);

		menu.createPrefItemCheckbox("Song Info Counter", "If enabled, this'll show information text about the current song on the left bottom corner of the screen.",
			(value) -> save.data.showSongInfo = value, save.data.showSongInfo);

		menu.createPrefItemCheckbox("Center Strumlines", "If enabled, this'll center the strums like in Kade Engine.",
			(value) -> save.data.centerStrums = value, save.data.centerStrums);

		menu.itemDesc.text = menu.preferenceDesc[menu.items.selectedIndex];

		return menu;
	}

	/**
	 * A helper function to easily add custom option items to OptionsMenu.
	 * Dynamic in customItems is {index:Int, label:String, callback:Void->Void, ?fireInstantly:Bool}
	 */
	function addCustomOptionItems(options:OptionsMenu, customItems:Array<Dynamic>) {
		var length = options.items.length + customItems.length;

		var items = [], requestIndices:Map<Int, Array<Int>> = [-1 => []];
		for (dyn in customItems) {
			var item = options.createItem(dyn.label, dyn.callback, dyn.fireInstantly);
			options.items.remove(item, true);

			if (!requestIndices.exists(dyn.index)) requestIndices.set(dyn.index, [items.length]);
			else requestIndices.get(dyn.index).push(items.length);

			items.push(item);
		}

		var members = options.items.members;
		var id = 0, y = (FlxG.height - length * 100) * 0.5 - 90;

		function checkRequestIndices() if (requestIndices.exists(id)) for (itemID in requestIndices.get(id)) {
			var item = items[itemID];
			item.y = y += 100;

			if (id == options.items.selectedIndex && members[id] != null) {
				members[id].idle();
				item.select();
			}

			options.items.insert(id++, item);
			checkRequestIndices();
		}

		while (id < length) {
			checkRequestIndices();

			if (members[id] != null) members[id].y = y += 100;
			id++;
		}
	}

	// Options & PlayState handling in funkin.modding.IScriptedClass.IStateChangingScriptedClass

	/**
	 * This is where to store the current FlxState to access PlayState or any other states, and
	 *  handling the state modification in runtime.
	 * 
	 * In HScript, you can dynamically access a variable like state to PlayState exclusive variables.
	 * whereas in normal Haxe, you would have to cast it everytime like cast(state, PlayState)
	 */
	var state:FlxState;
	var inPlay:Bool = false;
	var inOptions:Bool = false;

	override function onStateChangeBegin(e:StateChangeScriptEvent) {
		inPlay = false;
		cleanup();
	}

	override function onStateChangeEnd(e:StateChangeScriptEvent) {
		state = e.targetState;

		// Use Std.isOfType to check if this is PlayState or OptionsState.
		if (Std.isOfType(state, PlayState)) onPlaystateEnter();
		else if (inOptions = Std.isOfType(state, OptionsState)) {
			initSave();

			var options = state.optionsCodex.pages.get("options");
			var modPreferences = state.optionsCodex.addPage("kadehud", buildModPreferencesMenu());
			if (options.hasMultipleOptions()) modPreferences.onExit.add(() -> state.optionsCodex.switchPage("options"));

			addCustomOptionItems(options, [
				{index: options.items.members.indexOf(options.items.getItem("PREFERENCES")) + 1,
					label: "KADE HUD", callback: () -> options.codex.switchPage("kadehud")}
			]);
		}
	}

	// funkin.modding.IScriptedClass.IPlayStateScriptedClass

	/**
	 * These should be the variables for PlayState.
	 * Define cleanup for to call/reuse the variables on onDestroy, onPlayStateEnter, onStateChangeEnd
	 *  (just incase), this is for to avoid memory leaks.
	 */
	var scoreText:FlxText;
	var timingText:FlxText;
	var timingTextTween:FlxTween;
	var kadeText:FlxText;
	var songPosOverlay:FunkinSprite;
	var songPosBar:FlxBar;
	var songPosText:FlxText;

	function cleanup() {
		if (scoreText != null) scoreText.destroy();
		if (timingText != null) timingText.destroy();
		if (timingTextTween != null) timingTextTween.cancel();
		if (kadeText != null) kadeText.destroy();
		if (songPosOverlay != null) songPosOverlay.destroy();
		if (songPosBar != null) songPosBar.destroy();
		if (songPosText != null) songPosText.destroy();
	}

	/**
	 * A Seperate statistics/tallies variables for PlayState.
	 * prevCombos - for to check combo breaks.
	 * maxScore, score - for accuracy, it requires a seperate score variable instead of PlayState.songScore
	 *  for Preferences like Account Hold to Accuracies, Simple Accuracy.
	 * 
	 * lastSongPos - for maxScore Holds (in somewhere timeline where FNF doesn't ties up Hold Bonus Score to
	 *  delta time)
	 * 
	 * lastScore, lastMaxScore - for detect any changes to score to update Score Text, it needs to make sure
	 *  to not causes any more changes to text or waste computing time on the same tallies.
	 * 
	 * nps - for NPS, obviously, it acts like a timer inserting itself from 1 then decrementing by delta
	 */
	var comboBreaks:Int;
	var tapMissed:Int;

	var lastSongPos:Float;
	var lastTimeLeft:Int = 0;
	var lastScore:Int = 0;
	var lastMaxScore:Int = 0;
	var nps:Array<Float> = [];

	var prevCombos:Int;
	var maxScore:Int;
	var score:Int;
	var timeLeft:Int;

	function resetStats() {
		comboBreaks = 0;
		tapMissed = 0;

		lastSongPos = 0;
		nps.resize(0);

		prevCombos = 0;
		maxScore = 0;
		score = 0;
	}

	/**
	 * This is where it implant the mod Kade HUD to PlayState.
	 * More explanation at the codes.
	 */
	function onPlaystateEnter() {
		inPlay = true;

		initSave(); // Init this mod save if it got destroyed "onDestroy".
		cleanup();
		if (!save.data.enabled) return;

		resetStats();

		// I imagine there would be competitive players using this shitty mod, so i'd like to cache the judgments to not cause any lag spikes.
		for (rating in ["sick", "good", "bad", "shit"]) FunkinSprite.cacheTexture(state.comboPopUps.noteStyle.buildJudgementSpritePath(rating));

		if (save.data.centerStrums) {
			state.playerStrumline.x = FlxG.width * 0.75 - state.playerStrumline.width * 0.5;
			state.opponentStrumline.x = FlxG.width * 0.25 -  state.opponentStrumline.width * 0.5;
		}

		// Re-use the available scoreText on PlayState instead of making one, then make a temporary a really small FlxText to PlayState.scoreText.
		// To not cause any crashes relating to Score Text not existing/memory leaks being rapidly changes.
		// (Which kinda defeats the entire purpose?)
		scoreText = state.scoreText;
		state.scoreText = new FlxText(0, 0, 1);
		state.scoreText.visible = false;
		state.scoreText.active = false;

		updateScoreText();

		if (save.data.showSongInfo) {
			state.add(kadeText = new FlxText(18, FlxG.height - 50, 0, state.currentChart.songArtist + "\n" + state.currentChart.songName + " - " + FlxStringUtil.toTitleCase(state.currentDifficulty), 20));
			kadeText.setFormat(Paths.font("vcr.ttf"), 16, -1, "left", FlxTextBorderStyle.OUTLINE_FAST, -16777216);
			kadeText.zIndex = 802;
			kadeText.cameras = [state.camHUD];
		}

		// Kinda stolen from Boloxd's Kade Timing mod, i thought just implement it to just one mod.
		// And make the implementation much accurate.
		if (save.data.showTiming) {
			state.add(timingText = new FlxText(0, 0, 120, "").setFormat(Paths.font("pixel.otf"), 18, 0, "center", FlxTextBorderStyle.OUTLINE_FAST));
			timingText.borderColor = 0xFF000000;
			timingText.borderSize = 2;
			timingText.zIndex = 801;
			timingText.cameras = [state.camHUD];
		}

		if (save.data.showTimer) {
			// I like to have the overlay image, that then it won't have pixelated artifacts sort of thing, full colored textures makes it crusty on the edges.
			songPosOverlay = FunkinSprite.create(0, 0, "timeBar");
			songPosOverlay.setPosition(Math.floor((FlxG.width - songPosOverlay.width) * 0.5), Preferences.downscroll ? FlxG.height - 17 - songPosOverlay.height : 17);
			songPosOverlay.zIndex = 802;

			songPosBar = new FlxBar(songPosOverlay.x + 2, songPosOverlay.y + 2, null, songPosOverlay.width - 4, 1);
			songPosBar.createGradientBar([0xAF000000], [Constants.COLOR_HEALTH_BAR_GREEN, Constants.COLOR_HEALTH_BAR_RED]);
			songPosBar.scale.y = songPosOverlay.height - 4;
			songPosBar.numDivisions = Math.min(songPosBar.width, 1024);
			songPosBar.zIndex = 801;
			songPosBar.updateHitbox();

			songPosText = new FlxText(songPosOverlay.x, Math.floor(songPosOverlay.y + (songPosBar.height - 15) * 0.5), songPosOverlay.width, "", 20);
			songPosText.setFormat(Paths.font("vcr.ttf"), 20, -1, "center", FlxTextBorderStyle.OUTLINE_FAST, -16777216);
			songPosText.zIndex = 803;
			songPosText.borderSize = 2;

			for (member in [songPosText, songPosBar, songPosOverlay]) {
				member.alpha = 0;
				member.cameras = [state.camHUD];
			}

			if (tweenSongPosNext) {
				tweenSongPos();
				tweenSongPosNext = false;
			}
		}
		else
			tweenSongPosNext = false;
	}

	// Not sure what was this for exactly, this just existed way back in the old version of this mod.
	var tweenSongPosNext:Bool = false;
	function tweenSongPos() {
		for (member in [songPosBar, songPosOverlay, songPosText]) {
			state.add(member);
			FlxTween.tween(member, {alpha: 1}, 1, {ease: FlxEase.circOut});
		}
	}

	/**
	 * From this on, i'm lazy to explain stuff.
	 * It's should be self-explanatory.
	 * 
	 * If you want more explanation, head back to FNF Source Code
	 * funkin.modding.events.ScriptEvent.
	 * All of the implemented script event callbacks should be there.
	 */

	/**
	 * e.difficulty
	 */
	override function onSongRetry(e:SongRetryEvent) {
		if (!save.data.enabled) return;
		resetStats();
	}

	/**
	 * e.step
	 */
	override function onCountdownEnd(e:CountdownScriptEvent) {
		if (!save.data.enabled) return;
		if (!inPlay) tweenSongPosNext = true;
		else if (save.data.showTimer) tweenSongPos();
	}

	/**
	 * e.judgement
	 * e.score
	 * e.isComboBreak
	 * e.hitDiff
	 * e.doesNotesplash
	 * 
	 * NoteScriptEvent
	 * e.note
	 * e.comboCount
	 * e.playSound
	 * e.healthChange
	 */
	override function onNoteHit(e:HitNoteScriptEvent) {
		if (!inPlay || !save.data.enabled) return;

		var note = e.note;
		if (!note.noteData.getMustHitNote()) return;

		nps.push(1); // Adds a variable starting from 1 to nps array to indicate that a note has been hit.
		maxScore += Scoring.PBOT1_MAX_SCORE; // Add the max score on note hit.

		// If any configurations isn't required to pass any of these statements, Then it's not using a custom score to calculate the accuracy.
		if (save.data.simpleAcc) {
			// If it's using Simple Accuracy configuration, round the added score to the custom score.
			switch (e.judgement) {
				case 'sick': score += Scoring.PBOT1_MAX_SCORE;
				case 'good': score += Scoring.scoreNotePBOT1(Scoring.PBOT1_SICK_THRESHOLD);
				case 'bad': score += Scoring.scoreNotePBOT1(Scoring.PBOT1_GOOD_THRESHOLD);
				case 'shit': score += Scoring.scoreNotePBOT1(Scoring.PBOT1_BAD_THRESHOLD);
			}
		}
		else if (!save.data.accHoldToAcc) {
			// If the current configuration do not account holds to accuracy, use the custom score instead.
			score += e.score;
		}

		// Show the timing difference label if a note has hit.
		if (save.data.showTiming) {
			timingText.setPosition(FlxG.width * 0.474 + 50 + state.comboPopUps.offsets[0], FlxG.height * 0.45 - 20 + state.comboPopUps.offsets[1]);
			timingText.text = FlxMath.roundDecimal(e.hitDiff, 2) + "ms";
			timingText.alpha = 1.0;

			switch (e.judgement) {
				case "good": timingText.color = 0x00FF00;
				case "sick": timingText.color = 0x00FFFF;
				default: timingText.color = 0xFF0000;
			}

			if (timingTextTween != null) timingTextTween.cancel();
			timingTextTween = FlxTween.tween(timingText, {alpha: 0}, 0.2, {startDelay: 0.1});
		}
	}

	/**
	 * e.note
	 * e.comboCount
	 * e.playSound
	 * e.healthChange
	 */
	override function onNoteMiss(e:NoteScriptEvent) {
		if (!inPlay || !save.data.enabled) return;

		var note = e.note;
		if (!note.noteData.getMustHitNote()) return;

		maxScore += Scoring.PBOT1_MAX_SCORE;
		score -= 10; // this one is hardcoded...
		prevCombos = Highscore.tallies.combo;
		comboBreaks++;
	}


	/**
	 * e.dir
	 * e.hasPossibleNotes
	 * e.healthChange
	 * e.scoreChange
	 * e.playSound
	 * e.playAnim
	 */
	override function onNoteGhostMiss(e:GhostMissNoteScriptEvent) {
		if (!inPlay || !save.data.enabled) return;

		score += e.scoreChange;
		tapMissed++;
	}

	/**
	 * e.elapsed
	 */
	override function onUpdate(e:UpdateScriptEvent) {
		if (!inPlay || !save.data.enabled) return;

		if (prevCombos > 0 && Highscore.tallies.combo <= Math.min(prevCombos, 0)) comboBreaks++;
		prevCombos = Highscore.tallies.combo;

		var songPos = Conductor.instance.songPosition, elapsed = e.elapsed;

		if (save.data.showNPS) {
			var i = nps.length;
			while (i-- > 0) if ((nps[i] -= elapsed) < 0) {
				// FlxArrayUtil.swapAndPop is inlined
				nps[i] = nps[nps.length - 1]; // swap element to remove and last element
				nps.pop();
			}
		}

		if (save.data.accHoldToAcc && state.playerStrumline != null) {
			if (!save.data.simpleAcc) score = state.songScore;

			if (songPos > lastSongPos) {
				var addScore:Int;
				for (hold in state.playerStrumline.holdNotes.group.members) {
					if (hold == null || !hold.alive || songPos <= hold.strumTime) continue;

					addScore = songPos < hold.noteData.length + hold.strumTime ? Math.floor(Constants.SCORE_HOLD_BONUS_PER_SECOND * elapsed) : 0;
					
					// Implement this whenever they fixed delta-time specified only hold bonus scores.
					//addScore = Constants.SCORE_HOLD_BONUS_PER_SECOND * 0.001 * Math.min(songPos - lastSongPos, Math.max(hold.noteData.length - hold.strumTime, 0));

					maxScore += addScore;
					if (save.data.simpleAcc && hold.hitNote && !hold.missedNote) score += addScore;
				}
			}
		}

		if (save.data.showTimer) {
			if ((timeLeft = Math.floor((state.currentSongLengthMs - songPos) * 0.001)) != lastTimeLeft)
				songPosText.text = state.currentChart.songName + " (" + FlxStringUtil.formatTime(timeLeft, false) + ")";

			songPosBar.value = (songPos / state.currentSongLengthMs) * 100;
			songPosBar.updateBar();
		}

		if (lastScore != score || lastMaxScore != maxScore) updateScoreText();

		lastScore = score;
		lastMaxScore = maxScore;
		lastTimeLeft = timeLeft;
		lastSongPos = songPos;
	}

	function updateScoreText() {
		//var tallies = Highscore.tallies;
		//var notes = tallies.sick + (tallies.good * 0.785) + (tallies.bad * 0.65) + (tallies.shit * 0.3);
		// (notes / (tallies.totalNotesHit + tallies.missed)
		var acc = maxScore < 1 ? 0 : (score / maxScore) * 100;
		var text = "Score: " + state.songScore;

		if (save.data.showNPS) text = "NPS: " + nps.length + " | " + text;

		if (save.data.showTapMisses && tapMissed != 0) text += " | (Tap Misses: " + tapMissed + ") Breaks: " + comboBreaks;
		else text += " | Combo Breaks: " + (comboBreaks + tapMissed);

		text += " | Accuracy: " + FlxMath.roundDecimal(acc, 2) + "% | " + getRating(acc);

		scoreText.text = text;
		scoreText.setPosition(state.healthBar.x + (state.healthBar.width - scoreText.width) * 0.5, state.healthBar.y + 33);
	}

	// Stolen from Kade Engine probably? not sure this is old code.
	var wifeConditions:Array<Array<Dynamic>> = [
		[99.9935, "AAAAA"],
		[99.980, "AAAA:"],
		[99.970, "AAAA."],
		[99.955, "AAAA"],
		[99.90, "AAA:"],
		[99.80, "AAA."],
		[99.70, "AAA"],
		[99, "AA:"],
		[96.50, "AA."],
		[93, "AA"],
		[90, "A:"],
		[85, "A."],
		[80, "A"],
		[70, "B"],
		[60, "C"]
	];

	function getRating(acc:Float):String {
		var tallies = Highscore.tallies, misses = tapMissed + comboBreaks, fc:String;
		if (misses > 0) {
			if (misses < 10) fc = "SDCB";
			else fc = "Clear";
		}
		else {
			if (tallies.bad > 0 || tallies.shits > 0) fc = "FC";
			else if (tallies.good > 0) fc = "GFC";
			else if (tallies.sick > 0) fc = "SFC";
			else fc = "N/A";
		}

		for (b in wifeConditions) if (b[0] < acc) return "(" + fc + ") " + b[1];
		return "(" + fc + ") D";
	}
}